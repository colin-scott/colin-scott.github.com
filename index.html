
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Rest for the Wicked</title>
  <meta name="author" content="Colin Scott">

  
  <meta name="description" content="Thoughts on distributed systems">
  
  <meta name="keywords" content="SDN, software-defined networking, distributed systems, troubleshooting, Berkeley, Colin Scott, Scott Shenker">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://colin-scott.github.io">
  <link href="http://cryptm.org/~hpb/images/C.favicon.ico" rel="icon">
  <link href="/assets/css/bootstrap.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/assets/css/bootstrap-responsive.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/syntax/syntax.css" media="screen, projection" rel="stylesheet" type="text/css">
  <style type="text/css">
    body {
      padding-bottom: 40px;
    }
    h1 {
      margin-bottom: 15px;
    }
    img {
      max-width: 100%;
    }
    .sharing, .meta, .pager {
      margin: 20px 0px 20px 0px;
    }
    .page-footer p {
      text-align: center;
    }
  </style>
  <script src="/javascripts/libs/jquery.js"></script>
  <script src="/javascripts/libs/modernizr-2.0.js"></script>
  <script src="/javascripts/libs/bootstrap.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Rest for the Wicked" type="application/atom+xml">
  
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-29849261-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <nav role="navigation"><div class="navbar">
  <div class="navbar-inner">
    <div class="container">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </a>

      <a class="brand" href="/">Rest for the Wicked</a>

      <div class="nav-collapse">
        <div class="navbar navbar-fixed-top">
  <div class="navbar-inner">
    <div class="container">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </a>
      <a class="brand" href="http://www.eecs.berkeley.edu/~rcs/index.html">Colin Scott</a>
      <div class="nav-collapse collapse">
        <ul class="nav">
          <li><a href="http://www.eecs.berkeley.edu/~rcs/index.html">Home</a></li>
          <li><a href="http://www.eecs.berkeley.edu/~rcs/about.html">About</a></li>
          <li><a href="http://www.eecs.berkeley.edu/~rcs/contact.html">Contact</a></li>
          <li><a href="http://www.eecs.berkeley.edu/~rcs/publications.html">Publications</a></li>
          <li class="active"><a href="http://colin-scott.github.com/">Blog</a></li>
          <li><a href="http://www.eecs.berkeley.edu/~rcs/life.html">Life</a></li>
          <li><a href="http://colin-scott.github.com/music">Music</a></li>
        </ul>
      </div><!--/.nav-collapse -->
    </div>
  </div>
</div>


        <ul class="nav pull-right" data-subscription="rss">
          <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
          
        </ul>

        
          <form class="pull-right navbar-search" action="http://google.com/search" method="get">
            <fieldset role="search">
              <input type="hidden" name="q" value="site:colin-scott.github.io" />
              <input class="search-query" type="text" name="q" results="0" placeholder="Search"/>
            </fieldset>
          </form>
        
      </div>
    </div>
  </div>
</div>
</nav>
  <div class="container">
    <div class="row-fluid">
      <div class="span9">
  
  
  
    <article>
      
  <header class="page-header">
    
      <h1 class="entry-title"><a href="/blog/2015/10/07/fuzzing-raft-for-fun-and-profit/">Fuzzing Raft for Fun and Publication</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-10-07T16:19:35-07:00" pubdate data-updated="true">Oct 7<span>th</span>, 2015</time>
        
         | <a href="/blog/2015/10/07/fuzzing-raft-for-fun-and-profit/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Research on distributed systems is often motivated by some variation of the following:</p>

<blockquote><p> Developers of distributed systems face notoriously difficult challenges, such as concurrency, asynchrony, and partial failure.</p></blockquote>

<p>That statement seems convincing enough, but it&rsquo;s rather abstract. In this post
we&rsquo;ll gain a concrete understanding of what makes distribution so challenging,
by describing correctness bugs we found in an <a href="https://github.com/ktoso/akka-raft">implementation</a> of the <a href="http://ramcloud.stanford.edu/raft.pdf">Raft consensus protocol</a>.</p>

<p>Raft is an interesting example because its authors designed it to be
understandable and straightforward to implement. As we&rsquo;ll see, implementing even the relatively
straightforward Raft spec correctly requires developers to deal with many difficult-to-anticipate
issues.</p>

<h3>Fuzz testing setup</h3>

<p>To find bugs we&rsquo;re going to employ fuzz testing. Fuzz tests are nice because
they help us exercise situations that developers don&rsquo;t anticipate
with unit or integration tests. In a distributed environment,
semi-automated testing techniques such as fuzzing are especially useful, since the number of possible
event orderings a system might encounter grows exponentially with the number
of events (e.g. failures, message deliveries)&mdash;far too many cases for developers to reasonably cover with
hand-written tests.</p>

<p>Fuzz testing generally requires two ingredients:</p>

<ol>
<li> Assertions to check.</li>
<li> A specification of what inputs the fuzzer should inject into the system.</li>
</ol>


<h4>Assertions</h4>

<p>The Raft protocol already has a set of nicely defined safety
conditions, which we&rsquo;ll use as our assertions.</p>

<div class="row">
  <div class="span1">
  </div>

  <div class="span5">
    <img src="http://www.eecs.berkeley.edu/~rcs/research/raft_invariants.png"
    alt="Raft Invariants" width=100%>
  </div>

  <div class="span5">
<p>
Figure 3 from the <a href="http://ramcloud.stanford.edu/raft.pdf">Raft paper</a> (copied left) shows Raft&#8217;s key invariants.
We use these invariants as our assertions. Each assertion should hold at
any point in Raft&#8217;s execution.
</p>

<p>
For good measure, we also add in one additional assertion:
no Raft process should crash due to an uncaught exception.
</p>

<p>
We&#8217;ll check these invariants by periodically halting the fuzz test and
inspecting the internal state of each Raft process. If any of the assertions
ever fails, we&#8217;ve found a bug.
</p>
  </div>
</div>


<p></br></p>

<h4>Input generation</h4>

<p>The trickier part is specifying what inputs the fuzzer should inject.
Generally speaking, inputs are anything processed by the system, yet created outside the control of
the system. In the case of distributed systems there are a few sources of
inputs:</p>

<ul>
<li>The network determines when messages are delivered.</li>
<li>Hardware may fail, and processes may (re)join the system at random points.</li>
<li>Processes outside the system (e.g. clients) may send messages
to processes within the system.</li>
</ul>


<p>To generate the last two types of inputs, we specify a function for creating random external messages (in the case of Raft: client commands)
as well as probabilities for how often each event type (external message sends, failures, recoveries) should be injected.</p>

<p>We gain control over the network by <a href="https://github.com/NetSys/demi">interposing</a> on the distributed system&rsquo;s RPC layer, using <a href="https://en.wikipedia.org/wiki/AspectJ">AspectJ</a>. For now, we target a
specific RPC system: <a href="http://akka.io/">Akka</a>. Akka is ideal because it provides
a narrow, general API that operates at a high level abstraction
based around the <a href="https://en.wikipedia.org/wiki/Actor_model">actor model</a>.</p>

<p>Our interposition essentially allows us to play god: we get to choose exactly when each
RPC message sent by the distributed system is delivered. We can delay, reorder, or drop any message the
distributed system tries to send. The basic architecture of our test harness
(which we call <a href="https://github.com/NetSys/demi">DEMi</a>) is shown below:</p>

<div class="row">
  <div class="span1">
  </div>

  <div class="span5">
<p>
Every time a process sends an RPC message, the Test Harness intercepts it and places
it into a buffer. The Test Coordinator later decides when to deliver that message to the recipient.
In a fully asynchronous network, the Test Coordinator can arbitrarily delay
and reorder messages.
</p>

<p>
The Test Coordinator also injects external events (external message sends, failures, recoveries)
at random according to the probability weights given by the fuzz test
specification.
</p>
  </div>

  <div class="span6">
    <img src="http://www.eecs.berkeley.edu/~rcs/research/test_infrastructure.png" alt="Test Harness" width=100%>
  </div>
</div>


<p>Interposing at the RPC layer has a few advantages over interposing at a
lower layer (e.g. the network layer, a la <a href="https://aphyr.com/tags/jepsen">Jepsen</a>).
Most importantly, we get fine-grained control over when each individual
(non-segmented) message is delivered. In contrast, iptables is a much more blunt tool: it only allow the tester
to drop or delay all packets between a given pair of processes [1].</p>

<p>Targeting applications built on Akka gives us one other
advantage: Akka provides a <a href="http://doc.akka.io/docs/akka/2.4.0/scala/scheduler.html">timer API</a> that obviates the need for application
developers to read directly from the system clock. Timers are a crucial part of distributed systems,
since they are used to detect failures. In Akka, timers are modeled
as messages, to be delivered to the process that set the timer at a later
point in the execution. Rather than waiting for the wall-clock time for each
timer to expire, we can deliver it right away, without the application
noticing any difference.</p>

<h3>Target implementation: akka-raft</h3>

<p>The Raft implementation we target is <a href="https://github.com/ktoso/akka-raft">akka-raft</a>. akka-raft is written by one of the
core Akka developers, <a href="https://github.com/ktoso">Konrad Malawski</a>. akka-raft is fully featured according to
the Raft <a href="https://raft.github.io/">implementation page</a>; it supports log
replication, membership changes, and log compaction. akka-raft has existing
unit and integration tests, but it has not yet been deployed in production.</p>

<p>UPDATE: Konrad asked me to include a short note, and I&rsquo;m glad to oblige:</p>

<blockquote><p>akka-raft is not an officially supported Akka module, but rather just a side project of Konrad&rsquo;s. The Akka modules themselves are much more rigorously tested before release.</p></blockquote>

<p>For our fuzz tests we set up a small 4-node cluster (quorum size=3). akka-raft
uses TCP as its default transport protocol, so we
configure <a href="https://github.com/NetSys/demi">DEMi</a> to deliver
pending messages one-at-a-time in a semi-random order that obeys FIFO order
between any pair of processes. We also tell DEMi to inject a given number of client
commands (as external messages placed into the pending message buffer), and
check the Raft invariants at a fixed interval throughout the execution. We do
not yet exercise auxiliary features of akka-raft, such as log compaction or
cluster membership changes.</p>

<h3>Bug we found</h3>

<p>For all of the bugs we found below, we first minimized the faulty execution
before debugging the root cause [2]. With the minimized execution in hand,
we walked through the sequence of message deliveries in the
minimized execution one at
a time, noting the current state of the process receiving the message. Based on
our knowledge of the way Raft is supposed to work, we found the places in
the execution that deviated from our understanding of correct behavior.
We then examined the akka-raft code to understand why it deviated, and came up
with a fix. We submitted all of our fixes as pull requests.</p>

<p>A few of these root causes had already been pointed out
by <a href="https://github.com/schuster">Jonathan Schuster</a> through a manual audit of the code, but
none of them had been verified with tests or fixed before we ran our fuzz
tests.</p>

<p>On with the results!</p>

<h4><a href="https://github.com/ktoso/akka-raft/issues/45">raft-45</a>: Candidates accept duplicate votes from the same election term.</h4>

<p>Raft is specified as a state machine with three states: <code>Follower</code>, <code>Candidate</code>,
and <code>Leader</code>. Candidates attempt to get themselves elected as leader by
soliciting a quorum of votes from their peers in a given election term (epoch).</p>

<p>In one of our early fuzz runs, we found a violation of &lsquo;Leader Safety&rsquo;, i.e. two
processes believed they were leader in the same election term. This is a bad
situation for Raft to be in, since the leaders may overwrite each other&rsquo;s log
entries, thereby violating the key linearizability guarantee that Raft is supposed to
provide.</p>

<p>The root cause here was that akka-raft&rsquo;s candidate state did not detect
duplicate votes from the same follower in the same election term.
(A follower might resend votes because it believed that an earlier vote was
dropped by the network). Upon receiving the duplicate vote, the candidate
counts it as a new vote and steps up to leader before it actually
achieved a quorum of votes.</p>

<h4><a href="https://github.com/ktoso/akka-raft/issues/46">raft-46</a>: Processes neglect to ignore certain votes from previous terms.</h4>

<p>After fixing the previous bug, we found another execution where two leaders
were elected in the same term.</p>

<p>In Raft, processes attach an &lsquo;election term&rsquo; number to all messages they send.
Receiving processes are supposed to ignore any messages that contain an
election term that is lower than what they believe is the current term.</p>

<div class="row">
  <div class="span1">
  </div>

  <div class="span4">
    <img src="http://www.eecs.berkeley.edu/~rcs/research/delayed_term.jpg" alt="Delayed Term" height="50" id="myheight">
  </div>

  <div class="span6">
<p>
akka-raft properly ignored lagging term numbers for some, but not all message
types. DEMi delayed the delivery of messages from previous
terms and uncovered a case where a candidate incorrectly accepted a vote message from
a previous election term.
</p>
  </div>
</div>


<h4><a href="https://github.com/ktoso/akka-raft/issues/56">raft-56</a>: Processes forget who they voted for.</h4>

<p>akka-raft is written as an <a href="http://doc.akka.io/docs/akka/snapshot/scala/fsm.html">FSM</a>. When
making a state transition, FSM processes specify both which state
they want to transition to, and which instance variables they want to keep
once they have transitioned.</p>

<div class="row">
  <div class="span1">
  </div>

  <div class="span6">
    <img src="http://www.eecs.berkeley.edu/~rcs/research/raft_fsm.png" alt="Raft FSM" width=100%>
  </div>

  <div class="span5">
<p>
All of the state transitions for akka-raft were correct except
one: when a candidate
steps down to follower (e.g., because it receives an <code>AppendEntries</code> message,
indicating that there is another leader in the cluster), it
<i>forgets</i> which process it previously voted for in that term. Now, when another
process requests a vote from it in the same term, it will vote again but this
time for a different process than it previously voted for, allowing
two leaders to be elected.
</p>
  </div>
</div>


<h4><a href="https://github.com/ktoso/akka-raft/issues/58">raft-58a</a>: Pending client commands delivered before initialization occurs.</h4>

<p>After ironing out leader election issues, we started finding other issues. In
one of our fuzz runs, we found that a leader process threw an assertion error.</p>

<p>When an akka-raft candidate first makes the state transition to leader, it does not
immediately initialize its state (the <code>nextIndex</code> and <code>matchIndex</code> variables).
It instead sends a message to itself,
and initializes its state when it receives that self-message.</p>

<p>Through fuzz testing, we found that it is possible that the candidate could have pending <code>ClientCommand</code> messages
in its mailbox, placed there <i>before</i> the candidate transitioned to leader
and sent itself the initialization message.
Once in the leader state, the Akka runtime will first deliver the <code>ClientCommand</code> message. Upon processing the <code>ClientCommand</code>
message the leader tries to replicate it to the rest of the cluster, and updates its
<code>nextIndex</code> hashmap.
Next, when the Akka runtime delivers the initialization self-message, it will <em>overwrite</em> the
value of <code>nextIndex</code>. When it reads from <code>nextIndex</code> later, it&rsquo;s possible for
it to throw an assertion error because the <code>nextIndex</code> values are
inconcistent with the contents of the leader&rsquo;s log.</p>

<h4><a href="https://github.com/ktoso/akka-raft/issues/58">raft-58b</a>: Ambiguous log indexing.</h4>

<p>In one of our fuzz tests, we found a case where the &lsquo;Log Matching&rsquo;
invariant was violated, i.e. log entries did not appear in the same order on
all machines.</p>

<p>According to the Raft paper, followers should <em>reject</em> <code>AppendEntries</code> requests from leaders that are
behind, i.e. <code>prevLogIndex</code> and <code>prevLogTerm</code> for the <code>AppendEntries</code> message are
behind what the follower has
in its log. The leader should continue decrementing its <code>nextIndex</code> hashmap
until the followers stop rejecting its <code>AppendEntries</code> attempts.</p>

<p>This should have happened in akka-raft too, except for one hiccup:
akka-raft decided to adopt 0-indexed logs, rather than 1-indexed logs as the
paper suggests. This creates a problem:
the initial value of <code>prevLogIndex</code> is ambiguous:</p>

<ul>
<li>followers can&rsquo;t distinguish between an <code>AppendEntries</code> for an empty log (<code>prevLogIndex</code> == 0)</li>
<li>an <code>AppendEntries</code> for the leader&rsquo;s 1st command (<code>prevLogIndex</code> == 0), and</li>
<li>an <code>AppendEntries</code> for the leader&rsquo;s 2nd command (<code>prevLogIndex</code> == 1 &ndash; 1 == 0).</li>
</ul>


<p>The last two cases need to be distinguishable.
Otherwise followers won&rsquo;t be able to reject inconsistent logs. This corner would have
been hard to anticipate; at first glance it seems fine to adopt the convention
that logs should be 0-indexed instead of 1-indexed.</p>

<h4><a href="https://github.com/ktoso/akka-raft/issues/42">raft-42</a>: Quorum computed incorrectly.</h4>

<p>We also found a fuzz test that ended in a violation of the &lsquo;Leader Completeness&rsquo; invariant, i.e. a newly elected leader
had a log that was irrecoverably inconsistent with the logs of previous leaders.</p>

<p>Leaders are supposed to
commit log entries to their state machine when they knows that a quorum (N/2+1) of
the processes in the cluster have that entry replicated in their logs.
akka-raft had a bug where it computed the highest replicated log index incorrectly.
First it sorted the values of <code>matchIndex</code> (which denote the highest log entry index
known to be replicated on each peer). But rather than computing the <em>median</em>
(or more specifically, the N/2+1&#8217;st) of the sorted entries, it computed the <em>mode</em> of the sorted
entries. This caused the leader to commit entries too early, before a quorum
actually had that entry replicated. In our fuzz test, message delays allowed another leader to become elected, but it did not have all
committed entries in its log due to the previously leader committing too soon.</p>

<h4><a href="https://github.com/ktoso/akka-raft/issues/62">raft-62</a>: Crash-recovery not yet supported, yet inadvertently triggerable.</h4>

<p>Through fuzz testing I found one other case where two leaders became elected in
the same term.</p>

<p>The Raft protocol assumes a crash-recovery failure model &mdash; that is, it allows
for the possibility that crashed nodes will rejoin the cluster (with non-volatile state
intact).</p>

<p>The current version of akka-raft does does not write anything to disk
(although the akka-raft developers intend to support persistence soon).
That&rsquo;s actually fine &mdash; it just means that akka-raft currently assumes a crash-stop failure
model, where crashed nodes are never allowed to come back.</p>

<p>The Akka runtime, however, has a <a href="http://doc.akka.io/docs/akka/snapshot/scala/fault-tolerance.html">default
behavior</a> that doesn&rsquo;t play nicely
with akka-raft&rsquo;s crash-stop failure assumption: it automatically restarts any process that throws an exception.
When the process restarts, all its state is reinitialized.</p>

<p>If for any reason, a process throws an exception after it has voted for
another candidate, it will later rejoin the cluster, having forgotten who it had
voted for (since all state is volatile). Similar to <a href="https://github.com/ktoso/akka-raft/issues/56">raft-56</a>,
this caused two leaders to be elected in our fuzz test.</p>

<h4><a href="https://github.com/ktoso/akka-raft/issues/66">raft-66</a>: Followers unnecessarily overwrite log entries.</h4>

<p>The last issue I found is only possible to trigger if the underlying
transport protocol is UDP, since it requires reorderings of messages between
the same source, destination pair. The akka-raft developers say they don&rsquo;t currently
support UDP, but it&rsquo;s on their radar.</p>

<p>The invariant violation here was a violation of the &lsquo;Leader Completeness&rsquo; safety property, where a leader is
elected that doesn&rsquo;t have all of the needed log entries.</p>

<p><img src="http://www.eecs.berkeley.edu/~rcs/research/UDP_bug.jpg" alt="Lamport Time Diagram" width=60%></p>

<p>Leaders replicate uncommitted <code>ClientCommands</code> to the rest of the cluster in batches.
Suppose a follower with an empty log receives an <code>AppendEntries</code> containing
two entries. The follower appends these to its log.</p>

<p>Then the follower subsequently receives an <code>AppendEntries</code> containing only the
first of the previous two entries. (This message was delayed, as shown in the
Lamport Time Diagram). The follower will inadvertently delete the second entry from its log.</p>

<p>This is not just a performance issue: after receiving an ACK from the follower, the leader is under the impression that the
follower has two entries in its log. The leader may have decided to commit both
entries if a quorum was achieved. If another leader becomes elected, it will not necessarily have
both committed entries in its log as it should.</p>

<h3>Conclusion</h3>

<p>The wide variety of bugs we found gets me really excited about how useful our
<a href="https://github.com/NetSys/demi">fuzzing and minimization tool</a> is turning out to be. The development toolchain for
distributed systems is seriously deficient, and I hope that testing techniques like
this see more widespread adoption in the future.</p>

<p>I left many details of our approach out of this post for brevity&rsquo;s sake,
particularly a description of my favorite part: how DEMi minimizes the faulty executions
it finds to make them easier to understand. Check
out our <a href="http://www.eecs.berkeley.edu/~rcs/research/nsdi_draft.pdf">paper draft</a> for more details!</p>

<h3>Footnotes</h3>

<p>[1] RPC layer interposition does come with a drawback: we&rsquo;re tied to a
particular RPC library. It would be extremely tedious for us to adapt
our interposition to the impressive range of systems Jepsen has been applied
to.</p>

<p>[2] How we perform this minimization is
outside the scope of this blog post. Minimization is, in my opinion, the most
interesting part of what we&rsquo;re doing here. Check out our
<a href="http://www.eecs.berkeley.edu/~rcs/research/nsdi_draft.pdf">paper draft</a> for more
information!</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header class="page-header">
    
      <h1 class="entry-title"><a href="/blog/2014/12/08/half-baked-idea-how-often-do-failure-detectors-falsely-accuse/">Half-baked Idea: Is Asynchrony Really That Bad? or: How Often Do Failure Detectors Falsely Accuse?</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-12-08T17:32:28-08:00" pubdate data-updated="true">Dec 8<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/12/08/half-baked-idea-how-often-do-failure-detectors-falsely-accuse/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Distributed systems have two distinguishing features:</p>

<ul>
<li>Asynchrony, or &ldquo;absence of synchrony&rdquo;: messages from one process to another
do not arrive immediately. In a fully asynchronous system, messages may be
delayed for unbounded periods of time. In contrast, synchronous
networks always provide bounded message delays.</li>
<li>Partial failure: some processes in the system may fail while other processes
continue executing.</li>
</ul>


<p>It&rsquo;s the combination of these two features that make distributed systems
really hard; the crux of many impossibility proofs is
that nodes in a fully asynchronous system can&rsquo;t distinguish message
delays from failures.</p>

<p>In practice, networks are somewhere between fully asynchronous and
synchronous. That is, most (but not all!) of the time, networks give us sufficiently predictable message
delays to allow nodes to coordinate successfully in the face of failures.</p>

<p>When designing a distributed algorithm however, common wisdom says that you should try to
make as few assumptions about the network as possible. The motivation for this
principle is that minimizing your algorithm&rsquo;s assumptions about message delays maximizes the likelihood that it will work when placed
in a real network (which may, in practice, fail to meet bounds on message delays).</p>

<p>On the other hand, if your network does in fact provide bounds
on message delays, you can often design simpler and more performant
algorithms on top of it. An example of this observation that I find particularly
compelling is <a href="https://syslab.cs.washington.edu/research/specpaxos/index.html">Speculative
Paxos</a>, which
co-designs a consensus algorithm and the underlying network to improve overall
performance.</p>

<p>At the risk of making unsubstantiated generalizations, I get the sense that
theorists (who have dominated the field of distributed computing until somewhat recently) tend
to worry a lot about corner cases that jeopardize correctness properties. That
is, it&rsquo;s the theorist who&rsquo;s telling us to minimize our assumptions.
In contrast, practitioners are often willing to sacrifice correctness in favor
of simplicity and performance, as long as the corner cases that cause the
system to violate correctness are sufficiently rare.</p>

<p>To resolve the tension between the theorists&#8217; and the practitioners&#8217; principles, my half-baked idea is that we
should attempt to answer the following question:
&ldquo;How asynchronous are our networks in practice&rdquo;?</p>

<p>Before outlining how one might answer this question, I need to provide a bit
of background.</p>

<h3>Failure Detectors</h3>

<p>In reaction to the overly pessimistic asynchrony assumptions made by impossibility
proofs, theorists spent about a decade [1] developing distributed algorithms for &ldquo;partially synchronous&rdquo; network models.
The key property of the partially synchronous model is that at some point in the execution of the distributed system, the
network will start to provide bounds on message delays, but the algorithm
won&rsquo;t know when that point occurs.</p>

<p>The problem with the partial asynchrony model is that algorithms built on top
of it (and their corresponding correctness proofs) are messy: the timing assumptions of the algorithm are strewn throughout
the code, and proving the algorithm correct requires you to pull those timing
assumptions through the entire proof until you can finally check at the end
whether they match up with the network model.</p>

<p>To make reasoning about asynchrony easier, a theorist named Sam Toueg along
with a few others at Cornell proposed the concept of <a href="http://www.cs.cornell.edu/home/sam/FDpapers/CT96-JACM.ps">failure detectors</a>.
Failure detectors allow algorithms to encapsulate timing assumptions:
instead of manually setting timers to detect failures, we design our
algorithms to ask an oracle about the presence of failures [2]. To implement the oracle, we
<a href="http://research.microsoft.com/en-us/people/weic/wdag97_hb.pdf">still</a> use timers,
but now we have all of our timing assumptions collected cleanly in one place.</p>

<p>Failure detectors form a hierarchy. The strongest failure detector has perfect
accuracy (it never falsely accuses nodes of failing) and perfect completeness
(it always informs all nodes of all failures). Weaker failure detectors might
make mistakes, either by falsely accusing nodes of having crashed, or by
neglecting to detect some failures. The different failure detectors
correspond to different points on the asynchrony spectrum: perfect failure
detectors can only be implemented in a fully synchronous network [3], whereas
imperfect failure detectors correspond to partial synchrony.</p>

<h3>Measuring Asynchrony</h3>

<p>One way to get a handle on our question is to measure the behavior of failure detectors in practice.
That is, one could implement imperfect failure detectors,
place them in networks of different kinds, and measure how often they falsely
accuse nodes of failing. If we have ground truth on when nodes actually fail
in a controlled experiment, we can quantify how often those corner cases theorists
are worried about come up.</p>

<p>Anyone interested in getting their hands dirty?</p>

<h4>Footnotes</h4>

<p>[1] Starting in <a href="http://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf">1988</a> and dwindling after <a href="http://www.cs.cornell.edu/home/sam/FDpapers/CT96-JACM.ps">1996</a>.</p>

<p>[2] Side note: failures detectors aren&rsquo;t widely used in practice. Instead, most
distributed systems use ad-hoc network timeouts strewn throughout the code. At best, distributed systems use
adaptive timers, again strewn throughout the code. A library or language
that encourages programmers to encapsulate
timing assumptions and explicitly handle failure detection information could go a long
way towards improving the simplicity, amenability to automated tools, and robustness
of distributed systems.</p>

<p>[3] Which is equivalent to saying that they can&rsquo;t be implemented. Unless you
can ensure that the network itself never suffers from any failures or
congestion, you can&rsquo;t guarantee perfect synchrony. Nonetheless, some of the most recent <a href="https://www.usenix.org/sites/default/files/conference/protected-files/vliu_nsdi13_slides.pdf">network designs</a> get us
pretty close.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header class="page-header">
    
      <h1 class="entry-title"><a href="/blog/2014/11/30/half-baked-idea-automatically-marking-defer-tags/">Half-Baked Idea: Automatically Marking Deferred Javascript</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-30T12:31:59-08:00" pubdate data-updated="true">Nov 30<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/11/30/half-baked-idea-automatically-marking-defer-tags/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>A typical web page is composed of multiple objects: HTML files, Javascript
files, CSS files, images, etc..</p>

<p>When your browser loads a web page, it executes a list of tasks:
first it needs to fetch the main HTML, then it can parse each of the
HTML tags to know what other objects to
fetch, then it can process each of the fetched objects and their effect on the
DOM, and finally it can render pixels to your screen.</p>

<p>To load your web page as fast as possible, the browser tries to execute as
many of these tasks as it can <em>in parallel</em>. The less time the browser
spends sitting idle waiting for tasks to finish, the faster the web page
will load.</p>

<p>It is not always possible to execute tasks in parallel. This is
because some tasks have dependencies on others. The most obvious example
is that the browser needs to fetch the main HTML before it can know
what other objects to fetch [1].</p>

<p>In general, the more dependencies a web page has,
the longer it will take to load. Prudent web developers structure their web
pages in a way that minimizes browsers&#8217; task dependencies.</p>

<p>A particularly nasty dependency is Javascript execution. Whenever the browser
encounters a Javascript tag, it stops all other parsing and rendering tasks, waits to fetch the
Javascript, executes it until completion, and finally restarts the previously
blocked tasks. Browsers enforce this dependency because Javascript can modify the DOM;
by modifying the DOM, Javascript might affect the execution of all other
parsing and rendering tasks.</p>

<p>Placing Javascript tags in the beginning of an HTML page can have a huge
performance hit, since each script adds 1 RTT plus computation time
to the overall page load time.</p>

<p>Fortunately, the HTML standard provides a mechanism that allows developers to mitigate this
cost: the <a href="http://www.w3schools.com/tags/att_script_defer.asp">defer attribute</a>. The defer attribute tells the browser
that it&rsquo;s OK to fetch and execute a Javascript tag asynchronously.</p>

<p>Unfortunately, using the defer tag is not straightforward. The issue is
that it&rsquo;s hard for the web developer to know whether it&rsquo;s safe to allow the browser to execute Javascript asynchronously.
For instance, the Javascript may actually need to modify the DOM to ensure the correct execution of the page, or it
may depend on other resources (e.g. other Javascript tags).</p>

<p>Forcing web developers to reason about these complicated (and often hidden!)
dependencies is, at best, a lot to ask for, and at worst, highly error-prone.
For this reason few web developers today make use of defer tags.</p>

<p>So here&rsquo;s my half-baked idea: wouldn&rsquo;t it be great if we had a compiler that
could automatically mark defer attributes? Specifically, let&rsquo;s apply static
or dynamic analysis to infer when it&rsquo;s safe for Javascript
tags to execute asynchronously. Such a tool could go a long way towards improving the
performance and correctness of the web.</p>

<h4>Footnotes</h4>

<p>[1] See the <a href="https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final177.pdf">WProf paper</a> for a nice overview of browser activity dependencies.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header class="page-header">
    
      <h1 class="entry-title"><a href="/blog/2014/11/13/half-baked-idea-distributed-systems-need-message-level-debuggers/">Half-Baked Idea: Distributed Systems Need Message-Level Debuggers</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-13T19:26:12-08:00" pubdate data-updated="true">Nov 13<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/11/13/half-baked-idea-distributed-systems-need-message-level-debuggers/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>gdb, although an incredibly powerful tool for debugging single programs, doesn&rsquo;t work
so well for distributed systems.</p>

<p>The crucial difference between a single program and a distributed system is that distributed
computation revolves around <em>network messages</em>. Distributed systems spend
much of their time doing nothing more than waiting for network messages. When
they receive a message, they perform computation, perhaps send out a few
network messages of their own, and then return to their default state of
waiting for more network messages.</p>

<p>Because there&rsquo;s a network separating the nodes of the distributed system, you
can&rsquo;t (easily) pause all processes and attach gdb. And, in the words of
<a href="https://twitter.com/armon/status/533050582995435520">Armon Dadgar</a>,
&ldquo;even if you could, the network is part of your system. Definitely not going to be able to gdb
attach to that.&rdquo;</p>

<p>Suppose that you decide to attach gdb to a single process in the distributed
system. Even then, you&rsquo;ll probably end up frustrated. You&rsquo;re going to spend most
of your time waiting on a <code>select</code> or <code>receive</code> breakpoint. And when your
breakpoint is triggered, you&rsquo;ll find that most of the
messages won&rsquo;t be relevant for triggering <em>your</em> bug. You need to
wait for a specific message, or even a specific sequence of messages, before
you&rsquo;ll be able to trace through the code path that leads to your bug.</p>

<p>Crucially, gdb doesn&rsquo;t give you the ability to control network
messages, yet network message are what drive the distributed
system&rsquo;s execution. In other words, gdb operates at a level of abstraction that is lower than what you
want.</p>

<p>Distributed systems need a different kind of debugger. What we need is a
debugger that will allow us to step through the distributed system&rsquo;s
execution at the level of network messages. That is, you should be able to
generate messages, control the order in which they arrive, and observe how the
distributed system reacts.</p>

<p>Shameless self-promotion: <a href="http://ucb-sts.github.io/sts/walkthrough#interactive_mode">STS</a>
supports an &ldquo;Interactive Mode&rdquo; that takes over control of the
(software) network separating the nodes of a distributed system. This allows
you to interactively reorder or drop messages, inject failures, or check
invariants. We need something like this for testing and debugging general distributed systems.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header class="page-header">
    
      <h1 class="entry-title"><a href="/blog/2014/11/13/half-baked-ideas/">Half-Baked Ideas</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-13T18:10:45-08:00" pubdate data-updated="true">Nov 13<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/11/13/half-baked-ideas/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>As a graduate student, I find that the rate of progress I&rsquo;m able to make on my current
research project is significantly lower than the rate at which I encounter
ideas for new research projects. Over time, this means that the number of
half-baked ideas jotted down in my notebook grows without bound.</p>

<p>In Academia, we sometimes feel dissuaded from sharing our half-baked ideas. Our
fear is that we may get &lsquo;scooped&rsquo;; that is, we worry that if we share an idea before we have a time to flesh it out,
someone else may take that idea and turn it into a fully-fledged publication, thereby stealing our opportunity to publish.</p>

<p>Until now, I haven&rsquo;t publicly shared any of my half-baked ideas. I would like to
change that [1].</p>

<p>So, in the hope of generating discussion, I&rsquo;ll be posting a series of
half-baked ideas. Please feel welcome to steal them, criticize them, or add to
them!</p>

<hr />

<p>[1] In part, this is because I have come to believe that academic caginess is petty. More importantly though, I
have come to the terms with the reality that I will not have time to pursue most of these ideas.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header class="page-header">
    
      <h1 class="entry-title"><a href="/blog/2014/10/01/performance-modeling-for-sdn/">Performance Modeling for Network Control Plane Systems</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-10-01T21:51:21-07:00" pubdate data-updated="true">Oct 1<span>st</span>, 2014</time>
        
         | <a href="/blog/2014/10/01/performance-modeling-for-sdn/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>At Berkeley I have the opportunity to work with some of the smartest undergrads around. One of the undergrads I work with,
<a href="https://plus.google.com/109177137524762864782/about">Andrew Or</a>, did some neat work on modeling the performance of network control plane systems (e.g. SDN controllers).
He decided to take a once-in-a-lifetime opportunity to join <a href="http://databricks.com/">Databricks</a> before we got the chance to publish his work, so in his stead I thought
I&rsquo;d share his work here.</p>

<p>An interactive version of his performance model can be found at this <a href="http://www.eecs.berkeley.edu/~rcs/research/convergence_modeling/">website</a>. Description from the website:</p>

<blockquote>
<p>A key latency metric for network control plane systems is convergence time: the duration between when a change occurs in a network and when the network has converged to an updated configuration that accommodates that change. The faster the convergence time, the better.<p><br />

<p>Convergence time depends on many variables: latencies between network devices, the number of network devices, the complexity of the replication mechanism used (if any) between controllers, storage latencies, etc. With so many variables it can be difficult to build an intuition for how the variables interact to determine overall convergence time.</p><br />

<p>The purpose of this tool is to help build that intuition. Based on analytic models of communication complexity for various replication and network update schemes, the tool quantifies convergence times for a given topology and workload. With it, you can answer questions such as &#8220;How far will my current approach scale while staying within my SLA?&#8221;, and &#8220;What is the convergence time of my network under a worst-case workload?&#8221;.</p>
</blockquote>


<p>The tool is insightful (e.g.
note the striking difference between SDN controllers and traditional routing protocols) and a lot of fun to play around with; I encourage you to check it out.
In case you are curious about the details of the model or would like to suggest
improvements, the code is available <a href="https://github.com/andrewor14/web-model">here</a>. We also have a 6-page write up of the work, available upon request.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header class="page-header">
    
      <h1 class="entry-title"><a href="/blog/2014/04/29/is-academia-a-good-place-to-build-real-software/">Is Academia a Good Place to Build Real Software?</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-29T19:56:04-07:00" pubdate data-updated="true">Apr 29<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/04/29/is-academia-a-good-place-to-build-real-software/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>I often overhear a recurring debate amongst researchers: is Academia a good
place to build real software systems? By &ldquo;real&rdquo;, we typically mean &ldquo;used&rdquo;,
particularly by people outside of academic circles.</p>

<p>There have certainly been some success stories. <a href="http://www.bsd.org/">BSD</a>,
<a href="http://llvm.org/">LLVM</a>, <a href="http://www.xenproject.org/">Xen</a>, and <a href="http://spark.apache.org/">Spark</a> come to mind.</p>

<p>Nonetheless, some argue that these success stories came about at a time
when the surrounding software ecosystem was nascent enough for a small group of researchers to
be able to make a substantial contribution, and that the ecosystem is normally
at a point where researchers cannot easily contribute. Consider for example that BSD was
initially released in 1977, when very few open source operating systems
existed. Now we have Linux, which has almost <a href="http://www.cnet.com/news/linux-development-by-the-numbers-big-and-getting-bigger/">1400 active
developers</a>.</p>

<p>Is this line of reasoning correct? Is the heyday of Academic systems software over? Will it ever come again?</p>

<p>Without a doubt, building real software systems requires substantial (wo)manpower; no
matter how great the idea is, implementing it will require raw effort.</p>

<p>This fact suggests an indirect way to evaluate our question. Let&rsquo;s assume that
(i) any given software
developer can only produce a fixed (constant) amount of coding progress in a fixed
timeframe and (ii) the maturity of the surrounding software ecosystem is
proportional to collective effort put into it. We can then approximate an
answer to our
question by looking at the number of software developers in industry vs. the number of
researchers over time.</p>

<p>It turns out that the <a href="http://www.bls.gov/">Bureau of Labor Statistics</a>
publishes exactly the <a href="http://www.bls.gov/data/">data</a> we need for the United States.
Here&rsquo;s what I found:</p>

<p><img src="http://www.eecs.berkeley.edu/~rcs/research/oes.jpg" alt="OES data" width=100%></p>

<p>Hm. The first thing we notice is that it&rsquo;s hard to even see the line for academic and industrial researchers.
To give you a sense of where it&rsquo;s at, the y-coordinate at May, 2013 for computer science teachers and professors is 35,770, two
orders of magnitude smaller than the 3,339,440 total employees in the software industry at that time.</p>

<p>What we really care about though is the ratio of employees in industry to number of researchers:</p>

<p><img src="http://www.eecs.berkeley.edu/~rcs/research/oes_ratio.jpg" alt="OES ratio data" width=100%></p>

<p>In the last few years, both the software industry and Academia are growing at roughly the same rate, whereas researchers in industrial
labs appear to be dropping off relative to the software industry. We can see this relative growth rate better by normalizing the datasets (dividing each datapoint by the maximum datapoint
in its series &mdash; might be better to take the derivative, but I&rsquo;m too lazy to
figure out how to do that at the moment):</p>

<p><img src="http://www.eecs.berkeley.edu/~rcs/research/oes_normalized.jpg" alt="OES normalized data" width=100%></p>

<p>The data for the previous graphs only goes back to 1995. The Bureau of Labor
Statistics also publishes coarser granularity going all the way to 1950 and beyond:</p>

<p><img src="http://www.eecs.berkeley.edu/~rcs/research/nes.jpg" alt="NES data" width=100%></p>

<p>(See the hump around 2001?)</p>

<p>Not sure if this data actually answers our initial question, but I certainly found it insightful!
If you&rsquo;d like more details on how I did this analysis, or would like to play around with the data for
yourself, see my <a href="https://github.com/colin-scott/go-bls-client">code</a>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header class="page-header">
    
      <h1 class="entry-title"><a href="/blog/2014/03/30/what-distinguishes-distributed-computing-from-parallel-computing/">What Distinguishes Distributed Computing From Parallel Computing?</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-03-30T11:29:00-07:00" pubdate data-updated="true">Mar 30<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/03/30/what-distinguishes-distributed-computing-from-parallel-computing/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>I recently came across a <a href="http://aphyr.com/posts/285-call-me-maybe-riak">statement</a> in <a href="https://twitter.com/aphyr">Aphyr&rsquo;s</a> excellent
<a href="http://aphyr.com/tags/jepsen">Jepsen</a> blog series that caught my eye:</p>

<blockquote><p>&ldquo;In a very real sense, [network] partitions are just really big windows of concurrency.&rdquo;</p></blockquote>

<p>This statement seems to imply that distributed systems are &ldquo;equivalent&rdquo;
to parallel (single-machine) computing systems, for the following reason: partitions,
which occur in a network but don&rsquo;t really occur on a single chip [0], appear to be the key
distinguishing property of distributed systems. But if partitions are just a
special case of concurrency, then there shouldn&rsquo;t be any fundamental reasons
why algorithms for multicore computational models
(such as <a href="http://en.wikipedia.org/wiki/Parallel_random-access_machine">PRAM</a>) wouldn&rsquo;t be perfectly suitable for solving all the
problems we might encounter in a distributed setting.
We know this to be false,
so I&rsquo;ve been trying to puzzle out precisely what
properties of distributed computing distinguish it from parallel computing
[1].</p>

<p>I&rsquo;ve been taught that distributed systems have two crucial features:</p>

<ul>
<li>Asynchrony, or &ldquo;absence of synchrony&rdquo;: messages from one process to another
do not arrive immediately. In a fully asynchronous system, messages may be
delayed for unbounded periods of time.</li>
<li>Partial failure: some processes in the system may fail while other processes
continue executing.</li>
</ul>


<!--
Observe that in a loose sense, network partitions are a form of partial failure,
because from the perspective of the other nodes in the system, a partitioned node
is indistinguishable from a crashed node.
-->


<p>Let&rsquo;s discuss these two properties separately.</p>

<h3>Asynchrony</h3>

<p>Parallel systems also exhibit asynchrony, as long it&rsquo;s possible for
there to be a delay between one process sending a message [2]
and the other processes having the opportunity to read that message. Even on a single
machine, this delay might be induced by locks within the operating system kernel,
or by the cache coherence protocol implemented in hardware on a multicore chip.</p>

<p>With this in mind, let&rsquo;s return to Aphyr&rsquo;s statement.
What exactly did he mean by &ldquo;big windows of concurrency&rdquo;?
His article focuses on what happens when multiple clients write to the same
database key, so by &ldquo;concurrency&rdquo; I think he is referring to situations where multiple processes
might simultaneously issue writes to the same piece of state. But if you
think about it, the entire execution is a &ldquo;big window of
concurrency&rdquo; in this sense, regardless of whether the database replicas are partitioned.
By &ldquo;big windows of concurrency&rdquo; I think Aphyr was really talking about <em>asynchrony</em> (or more
precisely, periods of high message delivery delays),
since network partitions are hard to deal with precisely because the messages
between replicas aren&rsquo;t deliverable until after the partition is recovered:
when replicas can&rsquo;t coordinate, it&rsquo;s challenging (or impossible, if the system chooses to enforce linearizability)
for them to correctly process those concurrent writes. Amending Aphyr&rsquo;s statement then:</p>

<blockquote><p>&ldquo;Network partitions are just really big windows of asynchrony.&rdquo;</p></blockquote>

<p>Does this amendment resolve our quandary? Someone could
rightly point out that because partitions don&rsquo;t really occur within a single chip [0],
parallel systems can effectively provide guarantees on how long message
delays can last [3], whereas partitions in distributed systems may last
arbitrarily long. Some algorithms designed for parallel computers might
therefore break in a distributed setting,
but I don&rsquo;t think this is really the distinction we&rsquo;re looking
for.</p>

<h3>Partial Failure</h3>

<p>Designers of distributed algorithms codify their assumptions
about the possible ways nodes can fail by specifying a &lsquo;failure model&rsquo;. Failure models might describe
how many nodes can fail&mdash;for example, quorum-based algorithms assume that no more
than N/2 nodes ever fail, otherwise they cannot make progress&mdash;or they might
spell out how individual crashed nodes behave. The latter constraint forms a
hierarchy, where weaker failure models (e.g. &lsquo;fail-stop&rsquo;, where crashed nodes are guaranteed to never
send messages again) can be reduced to special cases of stronger models (e.g.
&lsquo;Byzantine&rsquo;, where faulty nodes can behave arbitrarily, even possibly
mimicking the behavior of correct nodes) [4].</p>

<p>Throughout the Jepsen series, Aphyr tests distributed systems by (i) telling
clients to issue concurrent writes, (ii) inducing a network partition between
database replicas, and (iii) recovering the partition. Observe that Jepsen
never actually kills replicas! This failure model is actually weaker than fail-stop,
since nodes are guaranteed to eventually resume sending messages [5].
Aphyr&rsquo;s statement is beginning to make sense:</p>

<blockquote><p>&ldquo;Network partitions that are followed by network recovery are just really big windows of asynchrony.&rdquo;</p></blockquote>

<p>This statement is true; from the perspective of a node in the system, a network partition followed by a network recovery
is indistinguishable from a random spike in message delays, or peer nodes that
are just very slow to respond. In other words, a distributed system that
guarantees that messages will eventually be deliverable to all nodes is
equivalent to an asynchronous parallel system. But if any nodes in the
distributed system actually fail, we&rsquo;re no longer equivalent to a parallel
system.</p>

<h3>Who cares?</h3>

<p>This discussion might sound like academic hairsplitting, but I claim that
these distinctions have practical implications.</p>

<p>As an example, let&rsquo;s imagine that you need to make a choice between shared memory
versus message passing as the communication model for the shiny new distributed
system you&rsquo;re designing. If you come from a parallel computing background you
would know that message passing is actually equivalent to shared memory, in
the sense that you can use a message passing abstraction to implement
shared memory, and vice versa. You might therefore conclude that you
are free to choose whichever abstraction is more convenient or performant for
your distributed system. If you jumped to this conclusion you might end up
making your system more fragile without realizing it.
Message passing is not equivalent to shared memory in distributed systems [6],
precisely because distributed systems exhibit <em>partial failures</em>;
in order to correctly implement shared memory in a distributed system it must
always be possible to coordinate with a quorum, or
otherwise be able to accurately detect which nodes have failed. Message
passing does not have this limitation.</p>

<p>Another takeaway from this discussion is that Jepsen is actually testing a
fairly weak failure mode. Despite Jepsen&rsquo;s simplicity though, Aphyr has managed to uncover problems in
an impressive number of distributed databases. If we want to uncover yet more implicit assumptions
about how our systems behave, stronger failure modes seem like an
excellent place to look.</p>

<hr />

<p>[0] After I posted this blog post, Aphyr and others informed me that some of
the latest multicore chips are in fact facing partial failures between cores
due to voltage
issues. This is quite interesting, because as multicore chips grow in transistor density, the
distinction between parallel computing and distributed computing is becoming
more and more blurred: modern multicore chips face both unbounded
asynchrony (from the growing gap between levels of the memory hierarchy) and partial failure (from voltage
issues).</p>

<p>[1] Thanks to <a href="http://www.cs.berkeley.edu/~alig/">Ali Ghodsi</a> for helping me tease out the differences between these properties.</p>

<p>[2] or writing to shared memory, which is essentially the same as sending a
message.</p>

<p>[3] See, for example, PRAM or BSP, which assume that every node can
communicate with every other node within each &ldquo;round&rdquo;. It&rsquo;s trivial to solve
<a href="http://groups.csail.mit.edu/tds/papers/Lynch/pods83-flp.pdf">hard</a> problems like
consensus in this world, because you can always just take a majority
vote and decide within two rounds.</p>

<p>[4] See Ali Ghodsi&rsquo;s excellent <a href="http://www.cs.berkeley.edu/~alig/cs294-91/events-links.pptx">slides</a> for a taxonomy of these failure models.</p>

<p>[5] Note that this is not equivalent to &lsquo;crash-recovery&rsquo;. Crash-recovery is
actually stronger than fail-stop, because nodes <em>may</em> recover or they may
not.</p>

<p>[6] Nancy Lynch, &ldquo;Distributed Algorithms&rdquo;, Morgan Kaufmann, 1996.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header class="page-header">
    
      <h1 class="entry-title"><a href="/blog/2013/05/12/wan-vs-datacenter-link-reliability/">WAN vs. Datacenter Link Reliability</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-05-12T15:46:00-07:00" pubdate data-updated="true">May 12<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/05/12/wan-vs-datacenter-link-reliability/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>According to a study by Turner et al. [1], wide area network links have an
average of 1.2 to 2.7 days of downtime per year. This translates to roughly
two and a half 9&rsquo;s of reliability [2].</p>

<p>I was curious how this compared to datacenter links, so I took a look at Gill
et. al&rsquo;s paper [3] on datacenter network failures at Microsoft. Unfortunately some
of the data has been redacted, but I was able to reverse engineer the mean
link downtime per year with the help of <a href="http://www.eecs.berkeley.edu/~apanda/">Aurojit Panda&rsquo;s</a>
<a href="https://github.com/apanda/svg-points">svg-to-points</a> converter. The results
are interesting: out of all links types, the average downtime was 0.3 days.
This translates to roughly three and a half 9&rsquo;s of reliability, an order of magnitude greater
than WAN links.</p>

<p>Intuitively this makes sense. WAN links are much more prone to
<a href="http://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf">drunken hunters, bulldozers, wild dogs,</a>
<a href="http://www.zetatalk.com/newsletr/issue284.htm">ships dropping anchor</a> and the like than links within a <a href="http://www.wired.com/wiredenterprise/2012/10/data-center-easter-eggs/">secure</a> datacenter.</p>

<h4>Footnotes</h4>

<p>[1] Daniel Turner, Kirill Levchenko, Alex C. Snoeren, and Stefan Savage. California Fault Lines: Understanding the Causes and Impact of Network Failures, Table 4. SIGCOMM &lsquo;10.</p>

<p>[2] Note that this statistic is specifically about hardware failure, not overall network availability.</p>

<p>[3] Phillipa Gill, Navendu Jain, Nachiappan Nagappan. Understanding Network Failures in Data Centers: Measurement, Analysis, and Implications, Figures 8c &amp; 9c. SIGCOMM &lsquo;11</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header class="page-header">
    
      <h1 class="entry-title"><a href="/blog/2012/12/24/latency-trends/">Latency Trends</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-12-24T15:20:00-08:00" pubdate data-updated="true">Dec 24<span>th</span>, 2012</time>
        
         | <a href="/blog/2012/12/24/latency-trends/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>In 2010, Jeff Dean gave a <a href="http://goo.gl/0MznW">talk</a> that laid out
a list of <a href="https://gist.github.com/2843375">numbers</a> every programmer
should know. His list has since become relatively well known among the systems community.</p>

<p>The other day, a friend mentioned a latency number to me, and I realized that
it was an order of magnitude smaller than what I had memorized from
Jeff&rsquo;s talk. The problem, of course, is that hardware performance increases
exponentially! After some digging, I actually found that the numbers Jeff
quotes are over a decade old [1].</p>

<p>Partly inspired by my officemate <a href="http://www.eecs.berkeley.edu/~apanda/">Aurojit Panda</a>, who is collecting
awesome <a href="http://www.eecs.berkeley.edu/~rcs/research/hw_trends.xlsx">data</a> on
hardware performance, I decided to write a little tool [2] to visualize Jeff&rsquo;s
numbers as a function of time [3].</p>

<p>Without further ado,
<a href="http://www.eecs.berkeley.edu/~rcs/research/interactive_latency.html">here</a> it
is.</p>

<h4>Footnotes</h4>

<p>[1] Jeff&rsquo;s numbers are from 2001, and were first publicized by Peter Norvig in this
<a href="http://norvig.com/21-days.html#answers">article</a>.</p>

<p>[2] Layout stolen directly from <a href="https://github.com/ayshen">ayshen</a> on GitHub.</p>

<p>[3] The hardware trends I&rsquo;ve gathered are rough estimates. If you want to tweak
the parameters yourself, I&rsquo;ve made it really easy to do so &mdash; please send me
updates! Better yet, issue a <a href="https://github.com/colin-scott/interactive_latencies">pull request</a>.</p>
</div>
  
  


    </article>
  
  <ul class="pager">
    
    <li class="previous"><a href="/blog/page/2/">&larr; Older</a></li>
    
    <li><a href="/blog/archives">Blog Archives</a></li>
    
  </ul>
</div>
<aside class="sidebar-nav span3">
  
    <section class="well">
  <ul id="recent_posts" class="nav nav-list">
    <li class="nav-header">Recent Posts</li>
    
      <li class="post">
        <a href="/blog/2015/10/07/fuzzing-raft-for-fun-and-profit/">Fuzzing Raft for Fun and Publication</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/12/08/half-baked-idea-how-often-do-failure-detectors-falsely-accuse/">Half-baked idea: Is asynchrony really that bad? Or: how often do failure detectors falsely accuse?</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/30/half-baked-idea-automatically-marking-defer-tags/">Half-Baked Idea: Automatically Marking Deferred Javascript</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/13/half-baked-idea-distributed-systems-need-message-level-debuggers/">Half-Baked Idea: Distributed Systems Need Message-Level Debuggers</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/13/half-baked-ideas/">Half-Baked Ideas</a>
      </li>
    
  </ul>
</section>

<section class="well">
  <ul id="gh_repos" class="nav">
    <li class="nav-header">GitHub Repos</li>
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/colin-scott">@colin-scott</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        github.showRepos({
            user: 'colin-scott',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/asides/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo" class="page-footer"><hr>
<p>
  Copyright &copy; 2015 - Colin Scott -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'restforthewicked';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
